\chapter{Implementation}

This chapter details the implementation of Snapstore. This includes data structures and the synchronization algorithm. 

Snapstore was built to be cross-platform using Electron\footnote{http://electron.atom.io/}. We used web sockets\footnote{www.socket.io} for networking. Once a client is connected over a socket, Snapstore can constantly pull in and push out new snapshots that come in from that user and from other users. Sockets provide the additional benefit of allowing us to group users. We used this functionality to make ``rooms'' of users that have read and write access to a specific branch. Pushing changes on that branch out to those users is simple with sockets.

\section{Data Structures}

\subsection{Client}

Each local repository on the client has its own Mongo\footnote{https://www.mongodb.com/} database. Each database has a collection of snapshots, branches, groups, tags, and events. It also has one snapstore document and a binary large object (blob) collection. A data model representing each data structure and its attributes is shown in figure 4-1.

\begin{figure}
\includegraphics[max width= \linewidth]{DataModel}
\caption{Snapstore client data model.}
\label{arm:fig1}
\end{figure}

When a file is saved, the resulting snapshot must first decide what kind of snapshot it is. Whether it is a create, update, rename, delete, merge, or conflict snapshot dictates how it will populate its data fields. A create snapshot, for example, has no parent snapshot. When a snapshot is created, it is added to the snapshot collection, and its branch updates its head snapshots to include the new snapshot, while removing its parent. To read the history of a file, the head snapshot of the file is located, and the rest is found by searching backwards through the snapshot graph.

If two snapshots have the same content, they point to the same blob data in the blob collection to save space. This blob collection holds hashes of the content along with the binary content.

When a new branch is created, it is added to the database with only a name. If, however, it was cloned from another branch, the cloned branch will point to all head snapshots, groups, and tags from the original branch. When switching to a branch, the heads snapshots for the target branch are read and applied to the Snapstore folder.

The event collection stores all of the snapshots, groups, and tag events on the client that have not been confirmed by the server. As these events are confirmed, they are erased from the collection.

\subsection{Upstream}

On the upstream server, the snapshot, branch, group, tag, and content data structures are the exact same as those on the client. They are kept consistent with each local repository when a socket connection is open. A model of the data structures on the upstream is shown in figure 4-2.

\begin{figure}
\includegraphics[max width= \linewidth]{DataModelServer}
\caption{Snapstore server data model.}
\label{arm:fig1}
\end{figure}

The user model on the server is a mapping of users to branches to which they have access. When a user shared a branch with another user, that branch is added to this mapping for that user. The server uses this mapping to share data with the appropriate users.

\section{Keeping Data in Sync}

In Snapstore, users can work on a shared branch. As described in section 2.2.3, a shared branch is a line of development where a change from one user is propagated to all other users who are collaborators on that branch, keeping all of their Snapstore folders consistent.

However, this workflow can be difficult to maintain. Multiple users can be making edits at the same time, increasing concurrency issues. If two snapshots are made at the same time, there needs to be a way to resolve the snapshot graph. Also, a user can go offline and create snapshots, while their shared snapshot graphs are being written to by other, online users. Snapstore should be able to handle their reintroduction to the network without destroying the snapshot graph.

It is also important to maintain the ordering of events created by a single user. If a user creates a snapshot and then creates a group with that snapshot it in, it is necessary to send those two events in order to the server. Otherwise, the server might, for example, try to create a group containing a snapshot that doesn't exist.

We take the approach that any data that reaches the upstream server and is confirmed should be regarded as fact; it should never be undone. With this invariant, we designed a protocol algorithm for this process, called Distributed Event Synchronization Queue (DESQ).

Each client has their own ordering of events, or database operations, that are stored in a client queue until they are confirmed by the server. The DESQ algorithm seeks to reach eventual consistency between these queues so that every client on a shared branch has the same data.

\subsubsection{Client}

\begin{center}
%\begin{algorithm}[h]
\begin{figure}[ht]
\begin{algorithmic}[1]
\State $\textit{events} \gets \text{collection of }\textit{Events}$
\State $\textit{socket} \gets \text{server socket connection}$
\Listene{Database-Listener}
\On {new database action \emph{event} by user}
\State $events\text{.append(}event\text{)}$
\EndOn
\EndListene
\Listene{Events-Listener}
\On {new \emph{event} added to \emph{events}}
\State $\text{Network-Listener.off()}$
\State $\text{Events-Listener.off()}$
%\State $events.\text{append(}event\text{)}$
\State $\text{Client-DESQ()}$
\State $\text{Network-Listener.on()}$
\State $\text{Events-Listener.on()}$
\EndOn
\EndListene
\Listene{Network-Listener}
\On {network connection with server established}
\State $\text{Network-Listener.off()}$
\State $\text{Events-Listener.off()}$
\State $socket\text{.send("Check Events")}$
\State $\text{Client-DESQ()}$
\State $\text{Network-Listener.on()}$
\State $\text{Events-Listener.on()}$
\EndOn
\EndListene
\Procedure{Client-DESQ}{}
\If {$events\text{.size()} != 0$}
\State $socket.send(events\text{(0)})$
\EndIf
\On{ \emph{socket}.response(\emph{response, message})}:
\If {$message == \text{"Confirm" or "Duplicate"}$}
\State \emph{events}.remove(\emph{events}(0))
\If {$events\text{.size() != 0}$}
\State $socket\text{.send(}events(0)\text{)}$
\EndIf
\State \textbf{close}
\EndIf
\If {$message == \text{"Reject"}$}
\State Save \emph{response} \Comment{These snapshot events fix the conflict}
\State $events\text{(0).data.parent} = response\text{(-1)}$ \Comment{response(-1) is the head}
\State $socket\text{.send(}events(0)\text{)}$
\State \textbf{close}
\EndIf
\If {$message == \text{"New Event"}$}
\If {$response.data.parent \text{ is not a head snapshot}$}
\State \textbf{close}
\EndIf
\State Save \emph{response}
\State \textbf{close}
\EndIf
\EndOn
\EndProcedure
\end{algorithmic}
\caption{Client-DESQ pseudocode}\label{euclid}
\end{figure}
%\end{algorithm}
\end{center}
%%%%%%%%%%%%%%%%%%%

Client-DESQ can be called in one of two ways. Either a database action has occurred ( listener defined on line 3), or a network connection with the server has been established (listener defined on line 13). Once Client-DESQ is called, both listeners are turned off, and the algorithm cannot be called again until it has finished and both listeners are turned back on. This logic places an implicit lock on the algorithm.

If Client-DESQ is started via network connection, the client also queries the server to see if there are any new events the client needs (line 17). If there are, the server sends them back as ``New Events'', and the client saves them (line 40).

Once Client-DESQ begins, it sends the first event in the queue to the server (line 25). For each event that it sends, it waits for a response for the server before sending another (lines 30 and 35). This level of blocking ensures that events are sent to the server in the order they were created on the client.

If an event is confirmed by the server, or if it is a duplicate event, the client removes this event from their queue and either stops sending events if it has none or sends the next event (lines 27-30).

If a snapshot event is rejected by the server, the client saves the snapshot events that will fix the conflict and updates the event snapshot's parent to be the head (lines 32-34). It then sends the updated snapshot event again (line 35). 

\subsubsection{Server}

\begin{center}
%\begin{algorithm}[h]
\begin{figure}[h]
\begin{algorithmic}[1]
\Procedure{Server-DESQ}{}
\State $\textit{socket} \gets \text{client socket connection}$
\State $\textit{eventMap} \gets \text{persistent storage of unsent events}$
\On {\emph{socket}.receive(\emph{event})}:
\If {$event \text{ = "Check Events"}$}
\State $newEvents \gets eventMap[socket.user]$
\If {$newEvents\text{.size()} != 0$}
\State $socket\text{.send(}newEvents, \text{"New Event")}$
\State $eventMap[socket.user] = []$
\EndIf
\State \textbf{close}
\EndIf
\If {$\textit{event} \text{.data.id in database}$}
\State $socket\text{.send(}event, \text{"Duplicate")}$
\State \textbf{close}
\EndIf
\If {$\textit{event}\text{.type } != \text{snapshot}$}
\State $\text{Confirm-Event(}event, socket, eventMap\text{)}$
\State \textbf{close}
\Else
\If {$event\text{.data.parent is head snapshot}$}
\State $\text{Confirm-Event(}event, socket, eventMap\text{)}$
\State \textbf{close}
\Else
\State $conflictSnapshots \gets \text{All snapshots between }event\text{.parent and }head$
\State $socket\text{.send(}conflictSnapshots\text{,"Reject")}$
\State \textbf{close}
\EndIf
\EndIf
\EndOn
\EndProcedure
\Procedure{Confirm-Event}{event, socket, eventMap}
\State $socket\text{.send(}event, \text{"Confirm")}$
\For {each \emph{user} with access to \emph{event}.branch}
\If {\emph{user} is connected}
\State $socket\text{(}user\text{).send(}event, \text{"New Event")}$
\Else
\State \emph{eventMap}[\emph{user}].append(\emph{event})
\EndIf
\EndFor
\State \textbf{close}
\EndProcedure
\end{algorithmic}
\caption{Server-DESQ pseudocode}\label{euclid}
\end{figure}
%\end{algorithm}
\end{center}

Server-DESQ begins on the server when it receives an event from a client. If the server has already seen this event, it is flagged as a duplicate (line 6). The event is confirmed if it can be applied to the server without causing any conflicts in the data. This is the case for all group and tag events (line 10) and for snapshot events whose parent is a head snapshot (line 15).

%Push
Once the server confirms an event, the event must be propagated to all collaborators. The server finds all clients that have access to that event's branch and sends the event to them (line 10). Because this is a confirmed event coming from the server, the collaborators can apply this event to their local repository without adding it to their event queue.

%Reject
Snapshots are the only type of event that can cause a conflict, due to their inclusion in an ordered snapshot graph. All clients with access to this snapshot graph must agree on its order. The server will reject a client's snapshot event if the snapshot's snapshot graphs on the server and client are inconsistent (line 18). The rejected snapshot returns to the client with snapshots that will fix the inconsistencies.

In Git terms, if there is a conflict, the snapshot graph rebases and Snapstore tries to push that snapshot again. The rebasing keeps the snapshot graph and the workflow for the branch linear. However, while Git creates new commits during a rebase, Snapstore uses existing snapshots.

This protocol allows the system to handle consecutive rejections. This can occur when other clients are sending snapshot events to the server while another client's event is being rejected.


